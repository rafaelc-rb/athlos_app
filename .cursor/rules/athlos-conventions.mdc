---
description: Athlos project conventions and best practices for AI agents
alwaysApply: true
---

# Athlos — AI Agent Guide

## Documentation

Read the project docs before coding to understand context and decisions:

- `docs/CONTEXT.md` — project vision, modules, and future ideas
- `docs/ARCHITECTURE.md` — stack, app structure, entities, and evolution plan
- `docs/modules/TRAINING.md` — training module features
- `docs/modules/DIET.md` — diet module features

## Language

- **All code in English** — classes, variables, functions, comments, commits, doc comments
- Portuguese **only** in ARB files (`l10n/`) for user-facing strings

## Naming Conventions

- Classes, enums: `PascalCase`
- Variables, functions, parameters: `camelCase`
- Files and folders: `snake_case`
- Private members: prefix with `_`
- Boolean variables/getters: prefix with `is`, `has`, `can`, `should`

## Dart Best Practices

- Prefer `final` for local variables and fields that don't change
- Use `const` constructors wherever possible
- Prefer expression bodies for simple one-line functions
- Always specify types for public APIs; `var`/`final` is fine for locals with obvious types
- Use `sealed class` or `enum` for finite state types
- Handle all cases with `switch` expressions (exhaustive matching)

## Architecture Rules

See `docs/ARCHITECTURE.md` for full structure. Key rules:

- **Presentation never accesses DataSource directly** — always through a repository
- **Domain imports nothing from Data or Presentation** — it is the innermost layer
- **Repositories are abstracted by interfaces** in Domain — implementation in Data can be swapped without affecting other layers
- Each feature follows: `domain/` → `data/` → `presentation/`

## Riverpod

- Use `@riverpod` annotation (code generation) for all providers
- Use `ref.watch` in `build()` methods; `ref.read` for one-off actions (e.g. button callbacks)
- Use `ref.listen` for side effects (navigation, showing snackbars)
- Use `AsyncValue` pattern (`.when(data:, error:, loading:)`) for async state in the UI
- Keep providers small and focused — one responsibility per provider
- Repository providers go in `data/repositories/`; UI state providers in `presentation/`

## Drift (database)

- Versioned migrations — never alter old migrations, always create new ones
- Table names in plural (exercises, workouts, equipments)
- Use DAOs to organize queries by entity/feature
- Use type converters for enums and complex types
- Keep table definitions in dedicated files under `data/datasources/`

## go_router

- Route paths as constants in a dedicated file (e.g. `core/router/route_paths.dart`)
- Use `StatefulShellRoute` for bottom navigation
- Use redirect guards for future auth flows
- Use `GoRouterState` extension for typed route parameters

## UI / Flutter

- Never hardcode colors — always use `Theme.of(context).colorScheme`
- Never hardcode strings — use ARB files via `AppLocalizations`
- Always add a `Key` to widgets in lists (`ValueKey`, `ObjectKey`)
- Prefer `const` widgets to reduce rebuilds
- Extract reusable widgets; global ones in `lib/core/widgets/`, feature-specific in `presentation/widgets/`
- Use `SizedBox` instead of `Container` when only size is needed
- Prefer `gap` package or `SizedBox` over `Padding` for spacing between widgets
